/*******************************************************************************
 * Copyright (c) 2004-2010 Akos Horvath and Daniel Varro
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Akos Horvath - initial API and implementation
 *******************************************************************************/
package org.eclipse.viatra2.compiled.emf.runtime.term;

import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EStructuralFeature;
import org.eclipse.viatra2.compiled.emf.runtime.exception.ViatraCompiledRuntimeException;

/** Evaluates the EMF EObject and EAttribute based terms generated by EMF-IncQuery
 * @author Akos Horvath
 *
 */
public class VPMTermEvaluator {
	public static String name(Object o)throws ViatraCompiledRuntimeException{
		if (o instanceof EObject) {
			EObject element = (EObject)o;
			EStructuralFeature nameFeature = element.eClass().getEStructuralFeature("name");
			if (nameFeature != null && !nameFeature.isMany() && nameFeature instanceof EAttribute) {
				Object name = element.eGet(nameFeature);
				if (name != null) return name.toString();
			}
		}
		throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.GETNAME_FAILED);
	}
	
	//****************Conversion operation*******************
	
	
	/** Uses the [AND] relational operation on the input parameters
	 * @param op1 First parameter
	 * @param op2 Second parameter
	 * @return the result of the operation
	 * @throws GTASMRunTimeException
	 */
	public static Boolean and(Object op1, Object op2)throws ViatraCompiledRuntimeException{
		
		if(op1 instanceof Boolean)
		{
			if(op2 instanceof Boolean)
				return ((Boolean)op1)&&((Boolean)op2);
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		}
		else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"1");
		
	}
	
	/** Uses the [OR] relational operation on the input parameters
	 * @param op1 First parameter
	 * @param op2 Second parameter
	 * @return the result of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Boolean or(Object op1, Object op2)throws ViatraCompiledRuntimeException{
		if(op1 instanceof Boolean)
		{
			if(op2 instanceof Boolean)
				return ((Boolean)op1)||((Boolean)op2);
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		}
		else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"1");
	}
	
	/** Uses the [XOR] relational operation on the input parameters
	 * @param op1 First parameter
	 * @param op2 Second parameter
	 * @return the result of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Boolean xor(Object op1, Object op2)throws ViatraCompiledRuntimeException{
		if(op1 instanceof Boolean)
		{
			if(op2 instanceof Boolean)
				return !((Boolean)op1).equals((op2));
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		}
		else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"1");
	}
	

	/** Uses the [EQUALS] relational operation on the input parameters
	 * @param op1 First parameter
	 * @param op2 Second parameter
	 * @return the result of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Boolean equals(Object op1, Object op2)throws ViatraCompiledRuntimeException{
		return (op1.equals(op2));
	}
	

	/** Uses the [NOT EQUALS] relational operation on the input parameters
	 * @param op1 First parameter
	 * @param op2 Second parameter
	 * @return the result of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Boolean notEquals(Object op1, Object op2)throws ViatraCompiledRuntimeException{
		return !(op1.equals(op2));
	}
	

	/** Uses the [LESS THAN] relational operation on the input parameters
	 * @param op1 First parameter
	 * @param op2 Second parameter
	 * @return the result of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Boolean lessThan(Object op1, Object op2)throws ViatraCompiledRuntimeException{
		return lessThanInner(op1, op2, 1, 2); 
	}
		
	/** Uses the [GREATER THAN] relational operation on the input parameters
	 * @param op1 First parameter
	 * @param op2 Second parameter
	 * @return the result of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Boolean greaterThan(Object op1, Object op2)throws ViatraCompiledRuntimeException{
		return lessThanInner(op2, op1, 2, 1); 
	}
	
	
	
	/** Implements the [LESS THAN, GREATER THAN] relational operations
	 * @param op1 value of operand 1
	 * @param op2 value of operand 2
	 * @param op1Pos position of operand 1 in the relation
	 * @param op2Pos position of operand 2 in the relation
	 * @return value of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	private static Boolean lessThanInner(Object op1, Object op2, int op1Pos, int op2Pos)throws ViatraCompiledRuntimeException{
		if(op1 instanceof Integer)
		{
			if(op2 instanceof Integer)
				return ((Integer)op1)<((Integer)op2);
			else if(op2 instanceof Double)
				return (Double.valueOf((((Integer)op1).doubleValue()))<((Double)op2));
			else if(op2 == null)
				return Boolean.FALSE;
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op2Pos);
		}
		else if(op1 instanceof Double)
		{
			if(op2 instanceof Integer)
				return ((Double)op1)<(new Double(((Integer)op2)));
			else if(op2 instanceof Double)
				return ((Double)op1)<((Double)op2);
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op2Pos);
			
		}
		else if(op1 instanceof String)
		{
			if(op2 instanceof String)
				return ((((String)op1).compareTo(((String)op2)))<0);
			else if(op2 == null)
				return Boolean.FALSE;
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op2Pos);
		}
		else if(op1 instanceof Boolean)
		{
			if(op2 instanceof Boolean)
				return ((Boolean)op1)?(!((Boolean) op2)):Boolean.FALSE;
			else if(op2 == null)
					return Boolean.FALSE;
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op2Pos);
		}
		else if (op1 == null && op2 != null) return Boolean.TRUE;
		else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op1Pos);
	}
	
	
	/** Uses the [LESS THAN OR EQUAL] relational operation on the input parameters
	 * @param op1 First parameter
	 * @param op2 Second parameter
	 * @return the result of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Boolean lessThanorEqual(Object op1, Object op2)throws ViatraCompiledRuntimeException{
		return lessThanorEqualInner(op1, op2, 1, 1);
	}
	
	/** Uses the [GREATER THAN OR EQUAL] relational operation on the input parameters
	 * @param op1 First parameter
	 * @param op2 Second parameter
	 * @return the result of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Boolean greaterThanorEqual(Object op1, Object op2)throws ViatraCompiledRuntimeException{
		return lessThanorEqualInner(op2, op1, 2, 1);
	}
	
	/** Implements the [LESS THAN EQUAL, GREATER THAN EQUAL] relational operations
	 * @param op1 value of operand 1
	 * @param op2 value of operand 2
	 * @param op1Pos position of operand 1 in the relation
	 * @param op2Pos position of operand 2 in the relation
	 * @return value of the operation
	 * @throws ViatraCompiledRuntimeException
	 */
	private static Boolean lessThanorEqualInner(Object op1, Object op2, int op1Pos, int op2Pos) throws ViatraCompiledRuntimeException{
		if(op1 instanceof Integer)
		{
			if(op2 instanceof Integer)
				return ((Integer)op1)<=((Integer)op2);
			else if(op2 instanceof Double)
				return (Double.valueOf((((Integer)op1).doubleValue()))<=((Double)op2));
			else if(op2 == null)
				return Boolean.FALSE;
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op2Pos);
		}
		else if(op1 instanceof Double)
		{
			if(op2 instanceof Integer)
				return ((Double)op1)<=(new Double(((Integer)op2)));
			else if(op2 instanceof Double)
				return ((Double)op1)<=((Double)op2);
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op2Pos);
			
		}
		else if(op1 instanceof String)
		{
			if(op2 instanceof String)
				return Boolean.valueOf(((((String)op2).indexOf(((String)op1)))!=-1));
			else if(op2 == null)
				return Boolean.FALSE;
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op2Pos);
		}
		else if(op1 instanceof Boolean)
		{
			if(op2 instanceof Boolean)
				return ((Boolean)op1)?(((Boolean) op2)):Boolean.TRUE;
			else if(op2 == null)
					return Boolean.FALSE;
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op2Pos);
		}
		else if ((op1 == null && op2 != null) || (op1 == null && op2 == null)) return Boolean.TRUE;
		else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+op1Pos);
	}
	
	
	//************Arithmetic operations***********************
	
	
	/** The method executes the op1 + op2 operation according to the type of the operands. If not possible the method throws a ViatraCompiledRuntimeException exception
	 * @param op1 First operand
	 * @param op2 Second operand
	 * @return The result of the add operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Object plus(Object op1, Object op2) throws ViatraCompiledRuntimeException {
		
		if (op1 instanceof String||op2 instanceof String) 
		{
			return op1.toString()+op2.toString();
			// Only String allowed by now
			/*if(op2 instanceof String)
				return ((String) op1) + (op2.toString());
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2",termToBeEvaluated);*/
		} else if (op1 instanceof Double) 
		{ 
			// Double and Integer permitted
			if (op2 instanceof Double)
				return ((Double) op1) + ((Double) op2);
			else if (op2 instanceof Integer)
				return ((Double) op1)
						+ (Double.valueOf(((Integer) op2).doubleValue()));
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		} else if (op1 instanceof Integer) 
		{ 
			if (op2 instanceof Double)
				return (Double.valueOf(((Integer)op1).doubleValue() + ((Double) op2)));
			else if (op2 instanceof Integer)
				return ((Integer) op1) + ((Integer) op2);
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		}
		else if (op1 instanceof Boolean)
			if(op2 instanceof Boolean)
				return (Boolean)op1||(Boolean)op2;
			else
				throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"1");
		
	}

	/** The method executes the op1 - op2 operation according to the type of the operands. If not possible the method throws a ViatraCompiledRuntimeException exception
	 * @param op1 First operand
	 * @param op2 Second operand
	 * @return The result of the subtraction operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Object minus(Object op1, Object op2) throws ViatraCompiledRuntimeException {
		if (op1 instanceof Double) 
		{ 
			// Double and Integer permitted
			if (op2 instanceof Double)
				return ((Double) op1) - ((Double) op2);
			else if (op2 instanceof Integer)
				return ((Double) op1)
						- (Double.valueOf(((Integer) op2).doubleValue()));
			else throw new ViatraCompiledRuntimeException (ViatraCompiledRuntimeException .PARAM_NOT_SUITABLE_WITH_NO+"2");
		} else if (op1 instanceof Integer) 
		{ 
			if (op2 instanceof Double)
				return (Double.valueOf(((Integer)op1).doubleValue() - ((Double) op2)));
			else if (op2 instanceof Integer)
				return ((Integer) op1) - ((Integer) op2);
			else throw new ViatraCompiledRuntimeException (ViatraCompiledRuntimeException .PARAM_NOT_SUITABLE_WITH_NO+"2");
		}
		else if(op1 instanceof String)
			if(op2 instanceof String)
			{
				// If it ends with the String op2, the operation cuts off the ending.
				if(((String)op1).endsWith((String)op2))
				{
					return ((String)op1).substring(0,((String)op1).length()-((String)op2).length());
				}
				else return null; //ValueKind.UNDEF_LITERAL;
			}
			else throw new ViatraCompiledRuntimeException (ViatraCompiledRuntimeException .PARAM_NOT_SUITABLE_WITH_NO+"2");
		else throw new ViatraCompiledRuntimeException (ViatraCompiledRuntimeException .PARAM_NOT_SUITABLE_WITH_NO+"1");
		
	}
	
	/** The method executes the op1 * op2 operation according to the type of the operands. If not possible the method throws a ViatraCompiledRuntimeException exception
	 * @param op1 First operand
	 * @param op2 Second operand
	 * @return The result of the multiply operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Object multiply(Object op1, Object op2) throws ViatraCompiledRuntimeException {

		if (op1 instanceof Double) 
		{ 
			// Double and Integer permitted
			if (op2 instanceof Double)
				return ((Double) op1) * ((Double) op2);
			else if (op2 instanceof Integer)
				return ((Double) op1)
						* (Double.valueOf(((Integer) op2).doubleValue()));
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		} else if (op1 instanceof Integer) 
		{ 
			if (op2 instanceof Double)
				return (Double.valueOf(((Integer)op1).doubleValue() * ((Double) op2)));
			else if (op2 instanceof Integer)
				return ((Integer) op1) * ((Integer) op2);
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");					
		}
		else if (op1 instanceof Boolean)
			if(op2 instanceof Boolean)
				return (Boolean)op1&&(Boolean)op2;
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"1");
		
	}
	
	/** The method executes the op1 / op2 operation according to the type of the operands. If not possible the method throws a ViatraCompiledRuntimeException exception
	 * @param op1 First operand
	 * @param op2 Second operand
	 * @return The result of the divison operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Object division(Object op1, Object op2) throws ViatraCompiledRuntimeException {
		if (op1 instanceof Double) 
		{ 
			// Double and Integer permitted
			if (op2 instanceof Double)
				return ((Double) op1) / ((Double) op2);
			else if (op2 instanceof Integer)
				return ((Double) op1)
						/ (Double.valueOf(((Integer) op2).doubleValue()));
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		} else if (op1 instanceof Integer) 
		{ 
			if (op2 instanceof Double)
				return (Double.valueOf(((Integer)op1).doubleValue() / ((Double) op2)));
			else if (op2 instanceof Integer)
				return ((Integer) op1) / ((Integer) op2);
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		}
		else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"1");
		
	}
	/** The method executes the op1 % op2 operation according to the type of the operands. If not possible the method throws a ViatraCompiledRuntimeException exception
	 * @param op1 First operand
	 * @param op2 Second operand
	 * @return The result of the remainder operation
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Object remainder(Object op1, Object op2) throws ViatraCompiledRuntimeException {
//		 Only for Integer! 
		if (op1 instanceof Integer) 
		{ 
			if (op2 instanceof Integer)
				return ((Integer) op1) % ((Integer) op2);
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		}
		else if(op1 instanceof String)
			if(op2 instanceof String)
			{
				// If it begins with the String op2, the operation cuts off the beginning.
				
				if(((String)op1).substring(0, ((String)op2).length()).equals(op2))
				{
					return ((String)op1).substring(((String)op2).length());
				}
				else return op1;
			}
			else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"2");
		else throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.PARAM_NOT_SUITABLE_WITH_NO+"1");
		
		
	}
	
//***************************************converters*****************
	
	/** Returns the Boolean value of the input parameter. Throws a ViatraCompiledRuntimeException exception if it cannot be converted
	 * @param op1 the parameter to be converted
	 * @return the Boolean equivalent of the parameter
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Boolean toBoolean(Object op1) throws ViatraCompiledRuntimeException{
		
		if(op1 == null)
		{
			return Boolean.FALSE;
			
		}
		else if(op1 instanceof String)
		{
			return "true".equals(op1)?(Boolean.TRUE):("false".equals(op1)?Boolean.FALSE:null);
		}
		else if(op1 instanceof Double)
		{
			return (((Double)op1).equals(0.0))?Boolean.FALSE:Boolean.TRUE;
		}
		else if(op1 instanceof Integer)
		{
			return (((Integer)op1).equals(0))?Boolean.FALSE:Boolean.TRUE;
		}
		else if(op1 instanceof Boolean)
		{
			return (Boolean)op1;
		}
		else if(op1 instanceof EObject)
		{
			return Boolean.TRUE;
		}
				
		throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.CONVERSION_FAILED);
		
	}
	
	/**Returns the integer value of the input parameter. Throws a ViatraCompiledRuntimeException exception if it cannot be converted 
	 * @param op1 the parameter to be converted
	 * @return
	 * @throws ViatraCompiledRuntimeException
	 */
	public static Integer toInteger(Object op1) throws ViatraCompiledRuntimeException{

		if(op1 == null)
			throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.CONVERT_NULL_PARAMETER);
	
		if (op1 instanceof Integer)
			return (Integer)op1;
		else if (op1 instanceof Double)
			return ((Double) op1).intValue();
		else if (op1 instanceof String)
			try {
				return Integer.valueOf((String) op1);
			} catch (NumberFormatException e) {
				throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.CONVERSION_FAILED);
			}
		else if (op1 instanceof Boolean)
			return (Boolean)op1?(Integer)1:(Integer)0;
		else
			throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.CONVERSION_FAILED);		
				
	}
	/**Returns the double value of the input parameter. Throws a ViatraCompiledRuntimeException exception if it cannot be converted 
	 * @param op1 the parameter to be converted
	 * @return
	 * @throws ViatraCompiledRuntimeException
	 */

	public static Double toDouble(Object op1) throws ViatraCompiledRuntimeException{
	
		if(op1 == null)
			throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.CONVERT_NULL_PARAMETER);
	
		
		if (op1 instanceof Double)
			return (Double)op1;
		else if (op1 instanceof Integer)
			return new Double(((Integer) op1).doubleValue());
		else if (op1 instanceof String)
			try {
				return new Double((String) op1);
			} catch (NumberFormatException e) {
				//Oops, the String does not seem to be a valid arithmetic value...
				throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.CONVERSION_FAILED);		
			}
		else if (op1 instanceof Boolean)
			return (Boolean)op1?(Double)1.0:(Double)0.0;
		else
			throw new ViatraCompiledRuntimeException(ViatraCompiledRuntimeException.CONVERSION_FAILED);		
		
				
	}
	
	/** Tries to cast ot to an EObject if not possible returns null
	 * @param o the parameter to be casted.
	 * @return
	 */
	public static EObject toModelElement(Object o){
		return o instanceof EObject? (EObject)o:null;
	}
	
}
