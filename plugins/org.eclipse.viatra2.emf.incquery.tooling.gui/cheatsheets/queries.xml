<?xml version="1.0" encoding="UTF-8"?>
<cheatsheet
      title="Creating EMF-IncQuery queries">
   <intro href="http://viatra.inf.mit.bme.hu/incquery/language">
      <description>
         Queries return a set of EMF instance model objects that match the criteria specified in a query pattern. 
         To learn more about the graph pattern-based query language, push (?).</description>
   </intro>
   
    <item title="Creating a new query definition">
      <description>
      You need to specify the EMF metamodels (Ecore models) that contain the types that your queries will use. These Ecore models will be loaded into the EMF-IncQuery project.<br/>
      It is highly recommended that the EMF model code is generated prior to defining model queries with EMF-IncQuery.<br/><br/>
      
     
      </description>
      
      <subitem label="New query def wizard start"></subitem>
    
      <subitem skip="true" label="2nd page: give your pattern a name"></subitem>
    
    
      <subitem skip="true" label="2nd page: import packages"></subitem>
    
    
      <subitem skip="true" label="2nd page: pattern parameters"></subitem>
    
    
   </item>
   
   
   <item
         title="Writing query patterns">
      <description>
      <command
            required="false"
            serialization="org.eclipse.ui.browser.openBrowser(url=http://viatra.inf.mit.bme.hu/incquery/language)"/>
In the context of the school example, we define a pattern that matches connected pairs of Teachers and Schools. 
EMF-IncQuery allows the user and the programmer to determine which parameters are used as input and which are output when a query is actually being issued (instantiated), therefore the same pattern can be used to: <br/>
(a) list the Teachers of a given School (with School as an input parameter), <br/>
(b) or to find the School that is associated to a given Teacher (Teacher is the input parameter),  <br/>
(c) or to list all Schools with their Teachers (both are output parameters), <br/>
(d) or to simply verify whether a given object is a Teacher, the other one is a School, and that the Teacher is indeed associated to the School instance (both are input parameters). 
<br/><br/>
Inside the newly created .eiq file, paste the following code:<br/><br/>

  pattern TeachersOfSchool(T:Teacher, Sch:School) = {<br/>
    School.teachers(Sch,T);<br/>
  }<br/>
<br/>
}<br/>
TODO: some explanation on the meaning of this pattern.
      </description>
   </item>
   
   
  
  
   <item
         title="Inspecting the generated code">
      <description>
         EMF-IncQuery automatically generates Java source code for your query pattern definitions inside the src-gen folder located inside your EMF-IncQuery project. The code generation is carried out by a <b>builder</b> that can be disabled (i) either by disabling auto-build globally in your Eclipse workspace, (ii) or by a project-specific setting (project properties | EMF-IncQuery | Compiler | Uncheck "Compiler is activated". As the compilation can be a resource-intensive task (especially for large .eiq files), it is sometimes a good practice to disable it while you are actively working on your query definitions -- they can be completely tested and debugged without the compiler's support! 
         <br/><br/>
         The generated code consists of the following main components:<br/>
         TODO rewrite me:
* Reference the created plug-in from your code, and use the user-friendly query functions generated in the <b>patternmatchers.myMachine</b> package.<br/>
* Use signature classes in <b>signatures.myMachine</b> to represent a single match of a pattern, with handy overloads for comparison and readable string output.<br/>
* The internally used patternbuilders.myMachine package contains a representation of the parsed patterns, responsible for the actual pattern matching. <br/><br/>
      </description>
   </item>
   
   <item title="Executing queries on instance models with the Query Explorer"
      <description>
      TODO
      </description>
   
   </item>
   
</cheatsheet>
